# ==========================================
# Mathematische Operationen
# ==========================================

# Grundrechenarten
<math.+> (+ ?a ?b) (: + ?a ?b)
<math.*> (* ?a ?b) (: * ?a ?b)
<math.-> (- ?a ?b) (: - ?a ?b)
<math./> (/ ?a ?b) (: / ?a ?b)
<math.%> (% ?a ?b) (: % ?a ?b)

# Fakultät - Base Cases haben Priorität
<math.fact.0> (fact 0) 1
<math.fact.1> (fact 1) 1
<math.fact.n> (fact ?n) (if (= ?n 0) 1 (* ?n (fact (- ?n 1))))

# Fibonacci - Base Cases haben Priorität
<math.fib.0> (fib 0) 0
<math.fib.1> (fib 1) 1
<math.fib.n> (fib ?n) (if (<= ?n 1) ?n (+ (fib (- ?n 1)) (fib (- ?n 2))))

# ==========================================
# Listen-Operationen
# ==========================================

# car/cdr (head/tail) - Base Cases zuerst
<list.car.empty> (car ()) (car ())
<list.cdr.empty> (cdr ()) (cdr ())
<list.car> (car (?head . ?tail)) ?head
<list.cdr> (cdr (?head . ?tail)) ?tail

# length - Rekursive Implementation
<list.length.empty> (length ()) 0
<list.length> (length (?head . ?tail)) (+ 1 (length ?tail))

# null? - Empty List Check
<list.null.empty> (null? ()) true
<list.null> (null? (?head . ?tail)) false

# cons - List Construction
<list.cons> (cons ?elem ?list) (?elem . ?list)

# List Constructor
<list.empty> (list) ()
<list.single> (list ?a) (?a)
<list.pair> (list ?a ?b) (?a . (?b))
<list.triple> (list ?a ?b ?c) (?a . (?b . (?c)))
<list.cons.build> (list ?head . ?tail) (?head . (apply list ?tail))

# append - List Concatenation
<list.append.empty.left> (append () ?list) ?list
<list.append> (append (?head . ?tail) ?list) (cons ?head (append ?tail ?list))

# reverse - List Reversal (with helper)
<list.reverse> (reverse ?list) (reverse-helper ?list ())
<list.reverse.helper.empty> (reverse-helper () ?acc) ?acc
<list.reverse.helper> (reverse-helper (?head . ?tail) ?acc) (reverse-helper ?tail (cons ?head ?acc))



# ==========================================
# Boolesche Logik
# ==========================================

<bool.and.false.left> (and false ?b) false
<bool.and.false.right> (and ?a false) false
<bool.and.true> (and true ?b) ?b
<bool.or.true.left> (or true ?b) true
<bool.or.true.right> (or ?a true) true
<bool.or.false> (or false ?b) ?b
<bool.not.true> (not true) false
<bool.not.false> (not false) true

# ==========================================
# Vergleichsoperationen
# ==========================================

<comp.eq> (= ?a ?b) (: == ?a ?b)
<comp.neq> (!= ?a ?b) (: != ?a ?b)
<comp.lt> (< ?a ?b) (: < ?a ?b)
<comp.gt> (> ?a ?b) (: > ?a ?b)
<comp.lte> (<= ?a ?b) (: <= ?a ?b)
<comp.gte> (>= ?a ?b) (: >= ?a ?b)

# ==========================================
# Bedingte Ausdrücke
# ==========================================

<cond.if.true> (if true ?then ?else) ?then
<cond.if.false> (if false ?then ?else) ?else

# ==========================================
# Utility-Funktionen
# ==========================================

<math.min> (min ?a ?b) (if (< ?a ?b) ?a ?b)
<math.max> (max ?a ?b) (if (> ?a ?b) ?a ?b)
<math.abs> (abs ?a) (if (>= ?a 0) ?a (- 0 ?a))
<math.even> (even? ?n) (= (% ?n 2) 0)
<math.odd> (odd? ?n) (!= (% ?n 2) 0)

# ==========================================
# NEUE Funktionen
# ==========================================

# map - Higher-Order Function
<hof.map.empty> (map ?fn ()) ()
<hof.map> (map ?fn (?head . ?tail)) (cons (apply ?fn ?head) (map ?fn ?tail))

# filter - Higher-Order Function
<hof.filter.empty> (filter ?pred ()) ()
<hof.filter.true> (filter ?pred (?head . ?tail)) (if (apply ?pred ?head) (cons ?head (filter ?pred ?tail)) (filter ?pred ?tail))

# fold-left - Reduction
<hof.fold.left.empty> (fold-left ?fn ?acc ()) ?acc
<hof.fold.left> (fold-left ?fn ?acc (?head . ?tail)) (fold-left ?fn (apply2 ?fn ?acc ?head) ?tail)

# sum
<math.sum.empty> (sum ()) 0
<math.sum> (sum (?head . ?tail)) (+ ?head (sum ?tail))

# product - Einfache Aggregation
<math.product.empty> (product ()) 1
<math.product> (product (?head . ?tail)) (* ?head (product ?tail))

# take - Liste kürzen
<list.take.zero> (take 0 ?list) ()
<list.take.empty> (take ?n ()) ()
<list.take> (take ?n (?head . ?tail)) (if (> ?n 0) (cons ?head (take (- ?n 1) ?tail)) ())

# drop - Liste kürzen
<list.drop.zero> (drop 0 ?list) ?list
<list.drop.empty> (drop ?n ()) ()
<list.drop> (drop ?n (?head . ?tail)) (if (> ?n 0) (drop (- ?n 1) ?tail) (?head . ?tail))

# range - Liste generieren
<list.range.end> (range ?n ?n) ()
<list.range> (range ?start ?end) (if (< ?start ?end) (cons ?start (range (+ ?start 1) ?end)) ())

# member? - Element suchen
<list.member.empty> (member? ?elem ()) false
<list.member.found> (member? ?elem (?elem . ?tail)) true
<list.member> (member? ?elem (?head . ?tail)) (if (= ?elem ?head) true (member? ?elem ?tail))

# Mathematische Funktionen
<math.square> (square ?x) (* ?x ?x)
<math.cube> (cube ?x) (* ?x (* ?x ?x))
<math.pow.zero> (pow ?x 0) 1
<math.pow> (pow ?x ?n) (if (= ?n 0) 1 (* ?x (pow ?x (- ?n 1))))

# String-ähnliche Operationen (wenn Sie Strings als Listen behandeln)
<string.concat.empty> (concat ()) ()
<string.concat> (concat ((?head . ?tail) . ?rest)) (append ?head (concat ?rest))

# ==========================================
# Einheiten normalisieren
# ==========================================

# Länge
<unit.length.mm.to.m> (to-meter (mm ?x)) (/ ?x 1000)
<unit.length.cm.to.m> (to-meter (cm ?x)) (/ ?x 100)
<unit.length.m.to.m> (to-meter (m ?x)) ?x
<unit.length.km.to.m> (to-meter (km ?x)) (* ?x 1000)

# Masse
<unit.mass.g.to.kg> (to-kg (g ?x)) (/ ?x 1000)
<unit.mass.kg.to.kg> (to-kg (kg ?x)) ?x
<unit.mass.t.to.kg> (to-kg (t ?x)) (* ?x 1000)

# Zeit
<unit.time.ms.to.s> (to-seconds (ms ?x)) (/ ?x 1000)
<unit.time.s.to.s> (to-seconds (s ?x)) ?x
<unit.time.min.to.s> (to-seconds (min ?x)) (* ?x 60)
<unit.time.h.to.s> (to-seconds (h ?x)) (* ?x 3600)

# Geschwindigkeit in m pro s
<unit.speed.kmh.to.mps> (to-mps (kmh ?v)) (/ (* ?v 1000) 3600)
<unit.speed.mps.to.mps> (to-mps (mps ?v)) ?v

# Beschleunigung in m pro s^2
<unit.acc.mps2.to.mps2> (to-mps2 (mps2 ?a)) ?a

# ==========================================
# Konstanten in Namespaces
# ==========================================

# Standard Schwerebeschleunigung nach WGS84
<physics.constants.si.g> (si:g) 9.80665

# Schulnah gerundet
<physics.constants.school.g> (school:g) 9.81

# ==========================================
# Physik mit Einheiten
# ==========================================

# Kraft aus Masse und Beschleunigung
<physics.force.u> (force-u ?mass ?acc) (* (to-kg ?mass) (to-mps2 ?acc))

# Geschwindigkeit aus Strecke und Zeit
<physics.velocity.u> (velocity-u ?dist ?time) (/ (to-meter ?dist) (to-seconds ?time))

# Arbeit aus Kraft und Strecke
<physics.work.u> (work-u ?force ?dist) (* ?force (to-meter ?dist))

# Bremsweg aus Geschwindigkeit und Reibbeiwert in zwei Varianten
<physics.brake.si> (brake-distance.si ?speed ?mu) (/ (square (to-mps ?speed)) (* (* 2 ?mu) (si:g)))
<physics.brake.school> (brake-distance.school ?speed ?mu) (/ (square (to-mps ?speed)) (* (* 2 ?mu) (school:g)))

