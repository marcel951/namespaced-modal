# ==========================================
# Mathematische Operationen - RICHTIGE REIHENFOLGE!
# ==========================================

# Grundrechenarten
<math.+> (+ ?a ?b) (: + ?a ?b)
<math.*> (* ?a ?b) (: * ?a ?b)
<math.-> (- ?a ?b) (: - ?a ?b)
<math./> (/ ?a ?b) (: / ?a ?b)
<math.%> (% ?a ?b) (: % ?a ?b)

# WICHTIG: Base Cases ZUERST, dann generische Regel!
# Fakultät - Base Cases haben Priorität
<math.fact.0> (fact 0) 1
<math.fact.1> (fact 1) 1
<math.fact.n> (fact ?n) (if (= ?n 0) 1 (* ?n (fact (- ?n 1))))

# Fibonacci - Base Cases haben Priorität
<math.fib.0> (fib 0) 0
<math.fib.1> (fib 1) 1
<math.fib.n> (fib ?n) (if (<= ?n 1) ?n (+ (fib (- ?n 1)) (fib (- ?n 2))))

# ==========================================
# Listen-Operationen
# ==========================================

# car/cdr (head/tail) - Base Cases zuerst
<list.car.empty> (car ()) (car ())
<list.cdr.empty> (cdr ()) (cdr ())
<list.car> (car (?head . ?tail)) ?head
<list.cdr> (cdr (?head . ?tail)) ?tail

# length - Rekursive Implementation
<list.length.empty> (length ()) 0
<list.length> (length (?head . ?tail)) (+ 1 (length ?tail))

# null? - Empty List Check
<list.null.empty> (null? ()) true
<list.null> (null? (?head . ?tail)) false

# cons - List Construction
<list.cons> (cons ?elem ?list) (?elem . ?list)

# append - List Concatenation
<list.append.empty.left> (append () ?list) ?list
<list.append> (append (?head . ?tail) ?list) (cons ?head (append ?tail ?list))

# reverse - List Reversal (with helper)
<list.reverse> (reverse ?list) (reverse-helper ?list ())
<list.reverse.helper.empty> (reverse-helper () ?acc) ?acc
<list.reverse.helper> (reverse-helper (?head . ?tail) ?acc) (reverse-helper ?tail (cons ?head ?acc))

# ==========================================
# Boolesche Logik
# ==========================================

<bool.and.false.left> (and false ?b) false
<bool.and.false.right> (and ?a false) false
<bool.and.true> (and true ?b) ?b
<bool.or.true.left> (or true ?b) true
<bool.or.true.right> (or ?a true) true
<bool.or.false> (or false ?b) ?b
<bool.not.true> (not true) false
<bool.not.false> (not false) true

# ==========================================
# Vergleichsoperationen
# ==========================================

<comp.eq> (= ?a ?b) (: == ?a ?b)
<comp.neq> (!= ?a ?b) (: != ?a ?b)
<comp.lt> (< ?a ?b) (: < ?a ?b)
<comp.gt> (> ?a ?b) (: > ?a ?b)
<comp.lte> (<= ?a ?b) (: <= ?a ?b)
<comp.gte> (>= ?a ?b) (: >= ?a ?b)

# ==========================================
# Bedingte Ausdrücke
# ==========================================

<cond.if.true> (if true ?then ?else) ?then
<cond.if.false> (if false ?then ?else) ?else

# ==========================================
# Utility-Funktionen
# ==========================================

<math.min> (min ?a ?b) (if (< ?a ?b) ?a ?b)
<math.max> (max ?a ?b) (if (> ?a ?b) ?a ?b)
<math.abs> (abs ?a) (if (>= ?a 0) ?a (- 0 ?a))
<math.even> (even? ?n) (= (% ?n 2) 0)
<math.odd> (odd? ?n) (!= (% ?n 2) 0)

# ==========================================
# NEUE Funktionen
# ==========================================

# map - Higher-Order Function
<hof.map.empty> (map ?fn ()) ()
<hof.map> (map ?fn (?head . ?tail)) (cons (apply ?fn ?head) (map ?fn ?tail))

# filter - Higher-Order Function
<hof.filter.empty> (filter ?pred ()) ()
<hof.filter.true> (filter ?pred (?head . ?tail)) (if (apply ?pred ?head) (cons ?head (filter ?pred ?tail)) (filter ?pred ?tail))

# fold-left - Reduction
<hof.fold.left.empty> (fold-left ?fn ?acc ()) ?acc
<hof.fold.left> (fold-left ?fn ?acc (?head . ?tail)) (fold-left ?fn (apply2 ?fn ?acc ?head) ?tail)

# sum
<math.sum.empty> (sum ()) 0
<math.sum> (sum (?head . ?tail)) (+ ?head (sum ?tail))

# product - Einfache Aggregation
<math.product.empty> (product ()) 1
<math.product> (product (?head . ?tail)) (* ?head (product ?tail))

# take - Liste kürzen
<list.take.zero> (take 0 ?list) ()
<list.take.empty> (take ?n ()) ()
<list.take> (take ?n (?head . ?tail)) (if (> ?n 0) (cons ?head (take (- ?n 1) ?tail)) ())

# drop - Liste kürzen
<list.drop.zero> (drop 0 ?list) ?list
<list.drop.empty> (drop ?n ()) ()
<list.drop> (drop ?n (?head . ?tail)) (if (> ?n 0) (drop (- ?n 1) ?tail) (?head . ?tail))

# range - Liste generieren
<list.range.end> (range ?n ?n) ()
<list.range> (range ?start ?end) (if (< ?start ?end) (cons ?start (range (+ ?start 1) ?end)) ())

# member? - Element suchen
<list.member.empty> (member? ?elem ()) false
<list.member.found> (member? ?elem (?elem . ?tail)) true
<list.member> (member? ?elem (?head . ?tail)) (if (= ?elem ?head) true (member? ?elem ?tail))

# Mathematische Funktionen
<math.square> (square ?x) (* ?x ?x)
<math.cube> (cube ?x) (* ?x (* ?x ?x))
<math.pow.zero> (pow ?x 0) 1
<math.pow> (pow ?x ?n) (if (= ?n 0) 1 (* ?x (pow ?x (- ?n 1))))

# String-ähnliche Operationen (wenn Sie Strings als Listen behandeln)
<string.concat.empty> (concat ()) ()
<string.concat> (concat ((?head . ?tail) . ?rest)) (append ?head (concat ?rest))
